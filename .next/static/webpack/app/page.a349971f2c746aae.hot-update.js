"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/auth.ts":
/*!*********************!*\
  !*** ./lib/auth.ts ***!
  \*********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ensureAuthOrStartOAuth: function() { return /* binding */ ensureAuthOrStartOAuth; }\n/* harmony export */ });\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n\nasync function ensureAuthOrStartOAuth(redirectTo) {\n    const supabase = (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_0__.getSupabaseClient)();\n    const { data } = await supabase.auth.getUser();\n    if (data.user) return \"proceeded\";\n    var _process_env_NEXT_PUBLIC_BASE_URL;\n    const base = (_process_env_NEXT_PUBLIC_BASE_URL = \"http://localhost:3000\") !== null && _process_env_NEXT_PUBLIC_BASE_URL !== void 0 ? _process_env_NEXT_PUBLIC_BASE_URL :  true ? window.location.origin : 0;\n    // Prefer popup flow so we don't navigate away from the landing page\n    try {\n        let popup = null;\n        if (true) {\n            const width = 600;\n            const height = 700;\n            const left = window.screenX + Math.max(0, (window.outerWidth - width) / 2);\n            const top = window.screenY + Math.max(0, (window.outerHeight - height) / 2);\n            // Open a blank popup synchronously to avoid popup blockers\n            popup = window.open(\"about:blank\", \"neuralift_google_oauth\", \"toolbar=0,location=0,menubar=0,scrollbars=1,resizable=1,width=\".concat(width, \",height=\").concat(height, \",top=\").concat(top, \",left=\").concat(left));\n        }\n        const { data: oauthData } = await supabase.auth.signInWithOAuth({\n            provider: \"google\",\n            options: base ? {\n                redirectTo: \"\".concat(base).concat(redirectTo),\n                skipBrowserRedirect: true\n            } : {\n                skipBrowserRedirect: true\n            }\n        });\n        const url = oauthData === null || oauthData === void 0 ? void 0 : oauthData.url;\n        if ( true && url) {\n            if (popup && !popup.closed) {\n                try {\n                    popup.location.href = url;\n                } catch (e) {\n                    popup = window.open(url, \"neuralift_google_oauth\");\n                }\n            } else {\n                popup = window.open(url, \"neuralift_google_oauth\");\n            }\n            return await new Promise((resolve)=>{\n                let settled = false;\n                const timeout = window.setTimeout(()=>{\n                    if (!settled) {\n                        settled = true;\n                        resolve(\"started_oauth\");\n                    }\n                }, 120000);\n                // Close watcher\n                const closeInterval = window.setInterval(async ()=>{\n                    if (!popup || popup.closed) {\n                        // Check if session exists now that popup is closed\n                        const { data: after } = await supabase.auth.getUser();\n                        if (!settled && after.user) {\n                            settled = true;\n                            window.clearTimeout(timeout);\n                            window.clearInterval(closeInterval);\n                            resolve(\"proceeded\");\n                        } else if (!settled && (!popup || (popup === null || popup === void 0 ? void 0 : popup.closed))) {\n                            settled = true;\n                            window.clearTimeout(timeout);\n                            window.clearInterval(closeInterval);\n                            resolve(\"started_oauth\");\n                        }\n                    }\n                }, 500);\n                const { data: sub } = supabase.auth.onAuthStateChange(async (event)=>{\n                    if (event === \"SIGNED_IN\" && !settled) {\n                        settled = true;\n                        try {\n                            popup === null || popup === void 0 ? void 0 : popup.close();\n                        } catch (e) {}\n                        window.clearTimeout(timeout);\n                        window.clearInterval(closeInterval);\n                        resolve(\"proceeded\");\n                    }\n                });\n                // Safety: clean up when promise settles\n                const finalize = (value)=>{\n                    try {\n                        var _sub_subscription_unsubscribe, _sub_subscription;\n                        sub === null || sub === void 0 ? void 0 : (_sub_subscription = sub.subscription) === null || _sub_subscription === void 0 ? void 0 : (_sub_subscription_unsubscribe = _sub_subscription.unsubscribe) === null || _sub_subscription_unsubscribe === void 0 ? void 0 : _sub_subscription_unsubscribe.call(_sub_subscription);\n                    } catch (e) {}\n                    try {\n                        popup === null || popup === void 0 ? void 0 : popup.close();\n                    } catch (e) {}\n                    return value;\n                };\n                // Wrap resolve to ensure cleanup\n                const originalResolve = resolve;\n                // @ts-expect-error\n                resolve = (v)=>originalResolve(finalize(v));\n            });\n        }\n    } catch (e) {}\n    // Fallback to full-page redirect if popup could not be opened\n    await supabase.auth.signInWithOAuth({\n        provider: \"google\",\n        options: base ? {\n            redirectTo: \"\".concat(base).concat(redirectTo)\n        } : undefined\n    });\n    return \"started_oauth\";\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hdXRoLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW1EO0FBRTVDLGVBQWVDLHVCQUF1QkMsVUFBa0I7SUFDN0QsTUFBTUMsV0FBV0gsZ0VBQWlCQTtJQUNsQyxNQUFNLEVBQUVJLElBQUksRUFBRSxHQUFHLE1BQU1ELFNBQVNFLElBQUksQ0FBQ0MsT0FBTztJQUM1QyxJQUFJRixLQUFLRyxJQUFJLEVBQUUsT0FBTztRQUNUQztJQUFiLE1BQU1DLE9BQU9ELENBQUFBLG9DQUFBQSx1QkFBZ0MsY0FBaENBLCtDQUFBQSxvQ0FBcUMsS0FBa0IsR0FBY0ksT0FBT0MsUUFBUSxDQUFDQyxNQUFNLEdBQUdDLENBQVNBO0lBQ3BILG9FQUFvRTtJQUNwRSxJQUFJO1FBQ0YsSUFBSUMsUUFBdUI7UUFDM0IsSUFBSSxJQUFrQixFQUFhO1lBQ2pDLE1BQU1DLFFBQVE7WUFDZCxNQUFNQyxTQUFTO1lBQ2YsTUFBTUMsT0FBT1AsT0FBT1EsT0FBTyxHQUFHQyxLQUFLQyxHQUFHLENBQUMsR0FBRyxDQUFDVixPQUFPVyxVQUFVLEdBQUdOLEtBQUksSUFBSztZQUN4RSxNQUFNTyxNQUFNWixPQUFPYSxPQUFPLEdBQUdKLEtBQUtDLEdBQUcsQ0FBQyxHQUFHLENBQUNWLE9BQU9jLFdBQVcsR0FBR1IsTUFBSyxJQUFLO1lBQ3pFLDJEQUEyRDtZQUMzREYsUUFBUUosT0FBT2UsSUFBSSxDQUNqQixlQUNBLDBCQUNBLGlFQUFpRlQsT0FBaEJELE9BQU0sWUFBd0JPLE9BQWROLFFBQU8sU0FBbUJDLE9BQVpLLEtBQUksVUFBYSxPQUFMTDtRQUUvRztRQUNBLE1BQU0sRUFBRWYsTUFBTXdCLFNBQVMsRUFBRSxHQUFHLE1BQU16QixTQUFTRSxJQUFJLENBQUN3QixlQUFlLENBQUM7WUFDOURDLFVBQVU7WUFDVkMsU0FBU3RCLE9BQU87Z0JBQUVQLFlBQVksR0FBVUEsT0FBUE8sTUFBa0IsT0FBWFA7Z0JBQWM4QixxQkFBcUI7WUFBSyxJQUFXO2dCQUFFQSxxQkFBcUI7WUFBSztRQUN6SDtRQUNBLE1BQU1DLE1BQU9MLHNCQUFBQSxnQ0FBRCxVQUFvQkssR0FBRztRQUNuQyxJQUFJLEtBQWtCLElBQWVBLEtBQUs7WUFDeEMsSUFBSWpCLFNBQVMsQ0FBQ0EsTUFBTWtCLE1BQU0sRUFBRTtnQkFDMUIsSUFBSTtvQkFBRWxCLE1BQU1ILFFBQVEsQ0FBQ3NCLElBQUksR0FBR0Y7Z0JBQUssRUFBRSxVQUFNO29CQUFFakIsUUFBUUosT0FBT2UsSUFBSSxDQUFDTSxLQUFLO2dCQUEyQjtZQUNqRyxPQUFPO2dCQUNMakIsUUFBUUosT0FBT2UsSUFBSSxDQUFDTSxLQUFLO1lBQzNCO1lBRUEsT0FBTyxNQUFNLElBQUlHLFFBQXVDQyxDQUFBQTtnQkFDdEQsSUFBSUMsVUFBVTtnQkFDZCxNQUFNQyxVQUFVM0IsT0FBTzRCLFVBQVUsQ0FBQztvQkFDaEMsSUFBSSxDQUFDRixTQUFTO3dCQUNaQSxVQUFVO3dCQUNWRCxRQUFRO29CQUNWO2dCQUNGLEdBQUc7Z0JBRUgsZ0JBQWdCO2dCQUNoQixNQUFNSSxnQkFBZ0I3QixPQUFPOEIsV0FBVyxDQUFDO29CQUN2QyxJQUFJLENBQUMxQixTQUFTQSxNQUFNa0IsTUFBTSxFQUFFO3dCQUMxQixtREFBbUQ7d0JBQ25ELE1BQU0sRUFBRTlCLE1BQU11QyxLQUFLLEVBQUUsR0FBRyxNQUFNeEMsU0FBU0UsSUFBSSxDQUFDQyxPQUFPO3dCQUNuRCxJQUFJLENBQUNnQyxXQUFXSyxNQUFNcEMsSUFBSSxFQUFFOzRCQUMxQitCLFVBQVU7NEJBQ1YxQixPQUFPZ0MsWUFBWSxDQUFDTDs0QkFDcEIzQixPQUFPaUMsYUFBYSxDQUFDSjs0QkFDckJKLFFBQVE7d0JBQ1YsT0FBTyxJQUFJLENBQUNDLFdBQVksRUFBQ3RCLFVBQVNBLGtCQUFBQSw0QkFBQUEsTUFBT2tCLE1BQU0sQ0FBRCxHQUFJOzRCQUNoREksVUFBVTs0QkFDVjFCLE9BQU9nQyxZQUFZLENBQUNMOzRCQUNwQjNCLE9BQU9pQyxhQUFhLENBQUNKOzRCQUNyQkosUUFBUTt3QkFDVjtvQkFDRjtnQkFDRixHQUFHO2dCQUVILE1BQU0sRUFBRWpDLE1BQU0wQyxHQUFHLEVBQUUsR0FBRzNDLFNBQVNFLElBQUksQ0FBQzBDLGlCQUFpQixDQUFDLE9BQU9DO29CQUMzRCxJQUFJQSxVQUFVLGVBQWUsQ0FBQ1YsU0FBUzt3QkFDckNBLFVBQVU7d0JBQ1YsSUFBSTs0QkFBRXRCLGtCQUFBQSw0QkFBQUEsTUFBT2lDLEtBQUs7d0JBQUksRUFBRSxVQUFNLENBQUM7d0JBQy9CckMsT0FBT2dDLFlBQVksQ0FBQ0w7d0JBQ3BCM0IsT0FBT2lDLGFBQWEsQ0FBQ0o7d0JBQ3JCSixRQUFRO29CQUNWO2dCQUNGO2dCQUVBLHdDQUF3QztnQkFDeEMsTUFBTWEsV0FBVyxDQUFDQztvQkFDaEIsSUFBSTs0QkFBRTt3QkFBQ0wsZ0JBQUFBLDJCQUFELHdCQUFjTSxZQUFZLGNBQTFCLDJGQUE0QkMsV0FBVyxjQUF2QztvQkFBNkMsRUFBRSxVQUFNLENBQUM7b0JBQzVELElBQUk7d0JBQUVyQyxrQkFBQUEsNEJBQUFBLE1BQU9pQyxLQUFLO29CQUFJLEVBQUUsVUFBTSxDQUFDO29CQUMvQixPQUFPRTtnQkFDVDtnQkFFQSxpQ0FBaUM7Z0JBQ2pDLE1BQU1HLGtCQUFrQmpCO2dCQUN4QixtQkFBbUI7Z0JBQ25CQSxVQUFVLENBQUNrQixJQUFxQ0QsZ0JBQWdCSixTQUFTSztZQUMzRTtRQUNGO0lBQ0YsRUFBRSxVQUFNLENBQUM7SUFFVCw4REFBOEQ7SUFDOUQsTUFBTXBELFNBQVNFLElBQUksQ0FBQ3dCLGVBQWUsQ0FBQztRQUFFQyxVQUFVO1FBQVVDLFNBQVN0QixPQUFPO1lBQUVQLFlBQVksR0FBVUEsT0FBUE8sTUFBa0IsT0FBWFA7UUFBYSxJQUFJYTtJQUFVO0lBQzdILE9BQU87QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvYXV0aC50cz9iZjdlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldFN1cGFiYXNlQ2xpZW50IH0gZnJvbSAnQC9saWIvc3VwYWJhc2UnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5zdXJlQXV0aE9yU3RhcnRPQXV0aChyZWRpcmVjdFRvOiBzdHJpbmcpOiBQcm9taXNlPCdwcm9jZWVkZWQnIHwgJ3N0YXJ0ZWRfb2F1dGgnPiB7XG4gIGNvbnN0IHN1cGFiYXNlID0gZ2V0U3VwYWJhc2VDbGllbnQoKTtcbiAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKTtcbiAgaWYgKGRhdGEudXNlcikgcmV0dXJuICdwcm9jZWVkZWQnO1xuICBjb25zdCBiYXNlID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQkFTRV9VUkwgPz8gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmxvY2F0aW9uLm9yaWdpbiA6IHVuZGVmaW5lZCk7XG4gIC8vIFByZWZlciBwb3B1cCBmbG93IHNvIHdlIGRvbid0IG5hdmlnYXRlIGF3YXkgZnJvbSB0aGUgbGFuZGluZyBwYWdlXG4gIHRyeSB7XG4gICAgbGV0IHBvcHVwOiBXaW5kb3cgfCBudWxsID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gNjAwO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gNzAwO1xuICAgICAgY29uc3QgbGVmdCA9IHdpbmRvdy5zY3JlZW5YICsgTWF0aC5tYXgoMCwgKHdpbmRvdy5vdXRlcldpZHRoIC0gd2lkdGgpIC8gMik7XG4gICAgICBjb25zdCB0b3AgPSB3aW5kb3cuc2NyZWVuWSArIE1hdGgubWF4KDAsICh3aW5kb3cub3V0ZXJIZWlnaHQgLSBoZWlnaHQpIC8gMik7XG4gICAgICAvLyBPcGVuIGEgYmxhbmsgcG9wdXAgc3luY2hyb25vdXNseSB0byBhdm9pZCBwb3B1cCBibG9ja2Vyc1xuICAgICAgcG9wdXAgPSB3aW5kb3cub3BlbihcbiAgICAgICAgJ2Fib3V0OmJsYW5rJyxcbiAgICAgICAgJ25ldXJhbGlmdF9nb29nbGVfb2F1dGgnLFxuICAgICAgICBgdG9vbGJhcj0wLGxvY2F0aW9uPTAsbWVudWJhcj0wLHNjcm9sbGJhcnM9MSxyZXNpemFibGU9MSx3aWR0aD0ke3dpZHRofSxoZWlnaHQ9JHtoZWlnaHR9LHRvcD0ke3RvcH0sbGVmdD0ke2xlZnR9YFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgeyBkYXRhOiBvYXV0aERhdGEgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguc2lnbkluV2l0aE9BdXRoKHtcbiAgICAgIHByb3ZpZGVyOiAnZ29vZ2xlJyxcbiAgICAgIG9wdGlvbnM6IGJhc2UgPyB7IHJlZGlyZWN0VG86IGAke2Jhc2V9JHtyZWRpcmVjdFRvfWAsIHNraXBCcm93c2VyUmVkaXJlY3Q6IHRydWUgfSBhcyBhbnkgOiB7IHNraXBCcm93c2VyUmVkaXJlY3Q6IHRydWUgfSBhcyBhbnlcbiAgICB9KTtcbiAgICBjb25zdCB1cmwgPSAob2F1dGhEYXRhIGFzIGFueSk/LnVybCBhcyBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHVybCkge1xuICAgICAgaWYgKHBvcHVwICYmICFwb3B1cC5jbG9zZWQpIHtcbiAgICAgICAgdHJ5IHsgcG9wdXAubG9jYXRpb24uaHJlZiA9IHVybDsgfSBjYXRjaCB7IHBvcHVwID0gd2luZG93Lm9wZW4odXJsLCAnbmV1cmFsaWZ0X2dvb2dsZV9vYXV0aCcpOyB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3B1cCA9IHdpbmRvdy5vcGVuKHVybCwgJ25ldXJhbGlmdF9nb29nbGVfb2F1dGgnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlPCdwcm9jZWVkZWQnIHwgJ3N0YXJ0ZWRfb2F1dGgnPihyZXNvbHZlID0+IHtcbiAgICAgICAgbGV0IHNldHRsZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAoIXNldHRsZWQpIHtcbiAgICAgICAgICAgIHNldHRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZSgnc3RhcnRlZF9vYXV0aCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMTIwMDAwKTtcblxuICAgICAgICAvLyBDbG9zZSB3YXRjaGVyXG4gICAgICAgIGNvbnN0IGNsb3NlSW50ZXJ2YWwgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGlmICghcG9wdXAgfHwgcG9wdXAuY2xvc2VkKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBzZXNzaW9uIGV4aXN0cyBub3cgdGhhdCBwb3B1cCBpcyBjbG9zZWRcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogYWZ0ZXIgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpO1xuICAgICAgICAgICAgaWYgKCFzZXR0bGVkICYmIGFmdGVyLnVzZXIpIHtcbiAgICAgICAgICAgICAgc2V0dGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKGNsb3NlSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICByZXNvbHZlKCdwcm9jZWVkZWQnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXNldHRsZWQgJiYgKCFwb3B1cCB8fCBwb3B1cD8uY2xvc2VkKSkge1xuICAgICAgICAgICAgICBzZXR0bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwoY2xvc2VJbnRlcnZhbCk7XG4gICAgICAgICAgICAgIHJlc29sdmUoJ3N0YXJ0ZWRfb2F1dGgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIDUwMCk7XG5cbiAgICAgICAgY29uc3QgeyBkYXRhOiBzdWIgfSA9IHN1cGFiYXNlLmF1dGgub25BdXRoU3RhdGVDaGFuZ2UoYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgaWYgKGV2ZW50ID09PSAnU0lHTkVEX0lOJyAmJiAhc2V0dGxlZCkge1xuICAgICAgICAgICAgc2V0dGxlZCA9IHRydWU7XG4gICAgICAgICAgICB0cnkgeyBwb3B1cD8uY2xvc2UoKTsgfSBjYXRjaCB7fVxuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKGNsb3NlSW50ZXJ2YWwpO1xuICAgICAgICAgICAgcmVzb2x2ZSgncHJvY2VlZGVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTYWZldHk6IGNsZWFuIHVwIHdoZW4gcHJvbWlzZSBzZXR0bGVzXG4gICAgICAgIGNvbnN0IGZpbmFsaXplID0gKHZhbHVlOiAncHJvY2VlZGVkJyB8ICdzdGFydGVkX29hdXRoJykgPT4ge1xuICAgICAgICAgIHRyeSB7IChzdWIgYXMgYW55KT8uc3Vic2NyaXB0aW9uPy51bnN1YnNjcmliZT8uKCk7IH0gY2F0Y2gge31cbiAgICAgICAgICB0cnkgeyBwb3B1cD8uY2xvc2UoKTsgfSBjYXRjaCB7fVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBXcmFwIHJlc29sdmUgdG8gZW5zdXJlIGNsZWFudXBcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICByZXNvbHZlID0gKHY6ICdwcm9jZWVkZWQnIHwgJ3N0YXJ0ZWRfb2F1dGgnKSA9PiBvcmlnaW5hbFJlc29sdmUoZmluYWxpemUodikpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGNhdGNoIHt9XG5cbiAgLy8gRmFsbGJhY2sgdG8gZnVsbC1wYWdlIHJlZGlyZWN0IGlmIHBvcHVwIGNvdWxkIG5vdCBiZSBvcGVuZWRcbiAgYXdhaXQgc3VwYWJhc2UuYXV0aC5zaWduSW5XaXRoT0F1dGgoeyBwcm92aWRlcjogJ2dvb2dsZScsIG9wdGlvbnM6IGJhc2UgPyB7IHJlZGlyZWN0VG86IGAke2Jhc2V9JHtyZWRpcmVjdFRvfWAgfSA6IHVuZGVmaW5lZCB9KTtcbiAgcmV0dXJuICdzdGFydGVkX29hdXRoJztcbn1cblxuXG4iXSwibmFtZXMiOlsiZ2V0U3VwYWJhc2VDbGllbnQiLCJlbnN1cmVBdXRoT3JTdGFydE9BdXRoIiwicmVkaXJlY3RUbyIsInN1cGFiYXNlIiwiZGF0YSIsImF1dGgiLCJnZXRVc2VyIiwidXNlciIsInByb2Nlc3MiLCJiYXNlIiwiZW52IiwiTkVYVF9QVUJMSUNfQkFTRV9VUkwiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIm9yaWdpbiIsInVuZGVmaW5lZCIsInBvcHVwIiwid2lkdGgiLCJoZWlnaHQiLCJsZWZ0Iiwic2NyZWVuWCIsIk1hdGgiLCJtYXgiLCJvdXRlcldpZHRoIiwidG9wIiwic2NyZWVuWSIsIm91dGVySGVpZ2h0Iiwib3BlbiIsIm9hdXRoRGF0YSIsInNpZ25JbldpdGhPQXV0aCIsInByb3ZpZGVyIiwib3B0aW9ucyIsInNraXBCcm93c2VyUmVkaXJlY3QiLCJ1cmwiLCJjbG9zZWQiLCJocmVmIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXR0bGVkIiwidGltZW91dCIsInNldFRpbWVvdXQiLCJjbG9zZUludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJhZnRlciIsImNsZWFyVGltZW91dCIsImNsZWFySW50ZXJ2YWwiLCJzdWIiLCJvbkF1dGhTdGF0ZUNoYW5nZSIsImV2ZW50IiwiY2xvc2UiLCJmaW5hbGl6ZSIsInZhbHVlIiwic3Vic2NyaXB0aW9uIiwidW5zdWJzY3JpYmUiLCJvcmlnaW5hbFJlc29sdmUiLCJ2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/auth.ts\n"));

/***/ })

});