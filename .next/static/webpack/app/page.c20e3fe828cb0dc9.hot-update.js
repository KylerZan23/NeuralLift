"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/auth.ts":
/*!*********************!*\
  !*** ./lib/auth.ts ***!
  \*********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ensureAuthOrStartOAuth: function() { return /* binding */ ensureAuthOrStartOAuth; }\n/* harmony export */ });\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n\nasync function ensureAuthOrStartOAuth(redirectTo) {\n    const supabase = (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_0__.getSupabaseClient)();\n    const { data } = await supabase.auth.getUser();\n    if (data.user) return \"proceeded\";\n    var _process_env_NEXT_PUBLIC_BASE_URL;\n    const base = (_process_env_NEXT_PUBLIC_BASE_URL = \"http://localhost:3000\") !== null && _process_env_NEXT_PUBLIC_BASE_URL !== void 0 ? _process_env_NEXT_PUBLIC_BASE_URL :  true ? window.location.origin : 0;\n    // Prefer popup flow so we don't navigate away from the landing page\n    try {\n        const { data: oauthData } = await supabase.auth.signInWithOAuth({\n            provider: \"google\",\n            options: base ? {\n                redirectTo: \"\".concat(base).concat(redirectTo),\n                skipBrowserRedirect: true\n            } : {\n                skipBrowserRedirect: true\n            }\n        });\n        const url = oauthData === null || oauthData === void 0 ? void 0 : oauthData.url;\n        if ( true && url) {\n            const width = 600;\n            const height = 700;\n            const left = window.screenX + Math.max(0, (window.outerWidth - width) / 2);\n            const top = window.screenY + Math.max(0, (window.outerHeight - height) / 2);\n            const popup = window.open(url, \"neuralift_google_oauth\", \"toolbar=0,location=0,menubar=0,scrollbars=1,resizable=1,width=\".concat(width, \",height=\").concat(height, \",top=\").concat(top, \",left=\").concat(left));\n            return await new Promise((resolve)=>{\n                let settled = false;\n                const timeout = window.setTimeout(()=>{\n                    if (!settled) {\n                        settled = true;\n                        resolve(\"started_oauth\");\n                    }\n                }, 120000);\n                // Close watcher\n                const closeInterval = window.setInterval(async ()=>{\n                    if (!popup || popup.closed) {\n                        // Check if session exists now that popup is closed\n                        const { data: after } = await supabase.auth.getUser();\n                        if (!settled && after.user) {\n                            settled = true;\n                            window.clearTimeout(timeout);\n                            window.clearInterval(closeInterval);\n                            resolve(\"proceeded\");\n                        } else if (!settled && (!popup || (popup === null || popup === void 0 ? void 0 : popup.closed))) {\n                            settled = true;\n                            window.clearTimeout(timeout);\n                            window.clearInterval(closeInterval);\n                            resolve(\"started_oauth\");\n                        }\n                    }\n                }, 500);\n                const { data: sub } = supabase.auth.onAuthStateChange(async (event)=>{\n                    if (event === \"SIGNED_IN\" && !settled) {\n                        settled = true;\n                        try {\n                            popup === null || popup === void 0 ? void 0 : popup.close();\n                        } catch (e) {}\n                        window.clearTimeout(timeout);\n                        window.clearInterval(closeInterval);\n                        resolve(\"proceeded\");\n                    }\n                });\n                // Safety: clean up when promise settles\n                const finalize = (value)=>{\n                    try {\n                        var _sub_subscription_unsubscribe, _sub_subscription;\n                        sub === null || sub === void 0 ? void 0 : (_sub_subscription = sub.subscription) === null || _sub_subscription === void 0 ? void 0 : (_sub_subscription_unsubscribe = _sub_subscription.unsubscribe) === null || _sub_subscription_unsubscribe === void 0 ? void 0 : _sub_subscription_unsubscribe.call(_sub_subscription);\n                    } catch (e) {}\n                    try {\n                        popup === null || popup === void 0 ? void 0 : popup.close();\n                    } catch (e) {}\n                    return value;\n                };\n                // Wrap resolve to ensure cleanup\n                const originalResolve = resolve;\n                resolve = (v)=>originalResolve(finalize(v));\n            });\n        }\n    } catch (e) {}\n    // Fallback to full-page redirect if popup could not be opened\n    await supabase.auth.signInWithOAuth({\n        provider: \"google\",\n        options: base ? {\n            redirectTo: \"\".concat(base).concat(redirectTo)\n        } : undefined\n    });\n    return \"started_oauth\";\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Z0MsYUFBYSxDQUFDTDt3QkFDckJKLFFBQVE7b0JBQ1Y7Z0JBQ0Y7Z0JBRUEsd0NBQXdDO2dCQUN4QyxNQUFNYyxXQUFXLENBQUNDO29CQUNoQixJQUFJOzRCQUFFO3dCQUFDTCxnQkFBQUEsMkJBQUQsd0JBQWNNLFlBQVksY0FBMUIsMkZBQTRCQyxXQUFXLGNBQXZDO29CQUE2QyxFQUFFLFVBQU0sQ0FBQztvQkFDNUQsSUFBSTt3QkFBRXBCLGtCQUFBQSw0QkFBQUEsTUFBT2dCLEtBQUs7b0JBQUksRUFBRSxVQUFNLENBQUM7b0JBQy9CLE9BQU9FO2dCQUNUO2dCQUVBLGlDQUFpQztnQkFDakMsTUFBTUcsa0JBQWtCbEI7Z0JBQ3hCQSxVQUFVLENBQUNtQixJQUFxQ0QsZ0JBQWdCSixTQUFTSztZQUMzRTtRQUNGO0lBQ0YsRUFBRSxVQUFNLENBQUM7SUFFVCw4REFBOEQ7SUFDOUQsTUFBTW5ELFNBQVNFLElBQUksQ0FBQ1ksZUFBZSxDQUFDO1FBQUVDLFVBQVU7UUFBVUMsU0FBU1YsT0FBTztZQUFFUCxZQUFZLEdBQVVBLE9BQVBPLE1BQWtCLE9BQVhQO1FBQWEsSUFBSWE7SUFBVTtJQUM3SCxPQUFPO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2F1dGgudHM/YmY3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRTdXBhYmFzZUNsaWVudCB9IGZyb20gJ0AvbGliL3N1cGFiYXNlJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuc3VyZUF1dGhPclN0YXJ0T0F1dGgocmVkaXJlY3RUbzogc3RyaW5nKTogUHJvbWlzZTwncHJvY2VlZGVkJyB8ICdzdGFydGVkX29hdXRoJz4ge1xuICBjb25zdCBzdXBhYmFzZSA9IGdldFN1cGFiYXNlQ2xpZW50KCk7XG4gIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCk7XG4gIGlmIChkYXRhLnVzZXIpIHJldHVybiAncHJvY2VlZGVkJztcbiAgY29uc3QgYmFzZSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0JBU0VfVVJMID8/ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gOiB1bmRlZmluZWQpO1xuICAvLyBQcmVmZXIgcG9wdXAgZmxvdyBzbyB3ZSBkb24ndCBuYXZpZ2F0ZSBhd2F5IGZyb20gdGhlIGxhbmRpbmcgcGFnZVxuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YTogb2F1dGhEYXRhIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLnNpZ25JbldpdGhPQXV0aCh7XG4gICAgICBwcm92aWRlcjogJ2dvb2dsZScsXG4gICAgICBvcHRpb25zOiBiYXNlID8geyByZWRpcmVjdFRvOiBgJHtiYXNlfSR7cmVkaXJlY3RUb31gLCBza2lwQnJvd3NlclJlZGlyZWN0OiB0cnVlIH0gYXMgYW55IDogeyBza2lwQnJvd3NlclJlZGlyZWN0OiB0cnVlIH0gYXMgYW55XG4gICAgfSk7XG4gICAgY29uc3QgdXJsID0gKG9hdXRoRGF0YSBhcyBhbnkpPy51cmwgYXMgc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB1cmwpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gNjAwO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gNzAwO1xuICAgICAgY29uc3QgbGVmdCA9IHdpbmRvdy5zY3JlZW5YICsgTWF0aC5tYXgoMCwgKHdpbmRvdy5vdXRlcldpZHRoIC0gd2lkdGgpIC8gMik7XG4gICAgICBjb25zdCB0b3AgPSB3aW5kb3cuc2NyZWVuWSArIE1hdGgubWF4KDAsICh3aW5kb3cub3V0ZXJIZWlnaHQgLSBoZWlnaHQpIC8gMik7XG4gICAgICBjb25zdCBwb3B1cCA9IHdpbmRvdy5vcGVuKFxuICAgICAgICB1cmwsXG4gICAgICAgICduZXVyYWxpZnRfZ29vZ2xlX29hdXRoJyxcbiAgICAgICAgYHRvb2xiYXI9MCxsb2NhdGlvbj0wLG1lbnViYXI9MCxzY3JvbGxiYXJzPTEscmVzaXphYmxlPTEsd2lkdGg9JHt3aWR0aH0saGVpZ2h0PSR7aGVpZ2h0fSx0b3A9JHt0b3B9LGxlZnQ9JHtsZWZ0fWBcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZTwncHJvY2VlZGVkJyB8ICdzdGFydGVkX29hdXRoJz4ocmVzb2x2ZSA9PiB7XG4gICAgICAgIGxldCBzZXR0bGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKCFzZXR0bGVkKSB7XG4gICAgICAgICAgICBzZXR0bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc29sdmUoJ3N0YXJ0ZWRfb2F1dGgnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDEyMDAwMCk7XG5cbiAgICAgICAgLy8gQ2xvc2Ugd2F0Y2hlclxuICAgICAgICBjb25zdCBjbG9zZUludGVydmFsID0gd2luZG93LnNldEludGVydmFsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICBpZiAoIXBvcHVwIHx8IHBvcHVwLmNsb3NlZCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgc2Vzc2lvbiBleGlzdHMgbm93IHRoYXQgcG9wdXAgaXMgY2xvc2VkXG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IGFmdGVyIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKTtcbiAgICAgICAgICAgIGlmICghc2V0dGxlZCAmJiBhZnRlci51c2VyKSB7XG4gICAgICAgICAgICAgIHNldHRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbChjbG9zZUludGVydmFsKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgncHJvY2VlZGVkJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzZXR0bGVkICYmICghcG9wdXAgfHwgcG9wdXA/LmNsb3NlZCkpIHtcbiAgICAgICAgICAgICAgc2V0dGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKGNsb3NlSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICByZXNvbHZlKCdzdGFydGVkX29hdXRoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCA1MDApO1xuXG4gICAgICAgIGNvbnN0IHsgZGF0YTogc3ViIH0gPSBzdXBhYmFzZS5hdXRoLm9uQXV0aFN0YXRlQ2hhbmdlKGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICAgIGlmIChldmVudCA9PT0gJ1NJR05FRF9JTicgJiYgIXNldHRsZWQpIHtcbiAgICAgICAgICAgIHNldHRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdHJ5IHsgcG9wdXA/LmNsb3NlKCk7IH0gY2F0Y2gge31cbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbChjbG9zZUludGVydmFsKTtcbiAgICAgICAgICAgIHJlc29sdmUoJ3Byb2NlZWRlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU2FmZXR5OiBjbGVhbiB1cCB3aGVuIHByb21pc2Ugc2V0dGxlc1xuICAgICAgICBjb25zdCBmaW5hbGl6ZSA9ICh2YWx1ZTogJ3Byb2NlZWRlZCcgfCAnc3RhcnRlZF9vYXV0aCcpID0+IHtcbiAgICAgICAgICB0cnkgeyAoc3ViIGFzIGFueSk/LnN1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmU/LigpOyB9IGNhdGNoIHt9XG4gICAgICAgICAgdHJ5IHsgcG9wdXA/LmNsb3NlKCk7IH0gY2F0Y2gge31cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gV3JhcCByZXNvbHZlIHRvIGVuc3VyZSBjbGVhbnVwXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIHJlc29sdmUgPSAodjogJ3Byb2NlZWRlZCcgfCAnc3RhcnRlZF9vYXV0aCcpID0+IG9yaWdpbmFsUmVzb2x2ZShmaW5hbGl6ZSh2KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gY2F0Y2gge31cblxuICAvLyBGYWxsYmFjayB0byBmdWxsLXBhZ2UgcmVkaXJlY3QgaWYgcG9wdXAgY291bGQgbm90IGJlIG9wZW5lZFxuICBhd2FpdCBzdXBhYmFzZS5hdXRoLnNpZ25JbldpdGhPQXV0aCh7IHByb3ZpZGVyOiAnZ29vZ2xlJywgb3B0aW9uczogYmFzZSA/IHsgcmVkaXJlY3RUbzogYCR7YmFzZX0ke3JlZGlyZWN0VG99YCB9IDogdW5kZWZpbmVkIH0pO1xuICByZXR1cm4gJ3N0YXJ0ZWRfb2F1dGgnO1xufVxuXG5cbiJdLCJuYW1lcyI6WyJnZXRTdXBhYmFzZUNsaWVudCIsImVuc3VyZUF1dGhPclN0YXJ0T0F1dGgiLCJyZWRpcmVjdFRvIiwic3VwYWJhc2UiLCJkYXRhIiwiYXV0aCIsImdldFVzZXIiLCJ1c2VyIiwicHJvY2VzcyIsImJhc2UiLCJlbnYiLCJORVhUX1BVQkxJQ19CQVNFX1VSTCIsIndpbmRvdyIsImxvY2F0aW9uIiwib3JpZ2luIiwidW5kZWZpbmVkIiwib2F1dGhEYXRhIiwic2lnbkluV2l0aE9BdXRoIiwicHJvdmlkZXIiLCJvcHRpb25zIiwic2tpcEJyb3dzZXJSZWRpcmVjdCIsInVybCIsIndpZHRoIiwiaGVpZ2h0IiwibGVmdCIsInNjcmVlblgiLCJNYXRoIiwibWF4Iiwib3V0ZXJXaWR0aCIsInRvcCIsInNjcmVlblkiLCJvdXRlckhlaWdodCIsInBvcHVwIiwib3BlbiIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0dGxlZCIsInRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2xvc2VJbnRlcnZhbCIsInNldEludGVydmFsIiwiY2xvc2VkIiwiYWZ0ZXIiLCJjbGVhclRpbWVvdXQiLCJjbGVhckludGVydmFsIiwic3ViIiwib25BdXRoU3RhdGVDaGFuZ2UiLCJldmVudCIsImNsb3NlIiwiZmluYWxpemUiLCJ2YWx1ZSIsInN1YnNjcmlwdGlvbiIsInVuc3Vic2NyaWJlIiwib3JpZ2luYWxSZXNvbHZlIiwidiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/auth.ts\n"));

/***/ })

});